# 洪水淹没农田提取系统 - 使用说明

**版本**: v1.0 (严格ESA农田定义)
**日期**: 2025-12-21
**作者**: Linus Torvalds (Claude Sonnet 4.5)

---

## 目录

1. [系统概述](#系统概述)
2. [环境配置](#环境配置)
3. [快速开始](#快速开始)
4. [详细使用步骤](#详细使用步骤)
5. [输入输出说明](#输入输出说明)
6. [常见问题](#常见问题)
7. [API文档](#api文档)

---

## 系统概述

### 功能描述

本系统用于从Sentinel-1洪水监测数据和ESA WorldCover土地覆盖数据中，提取**被洪水淹没的农田范围**。

### 核心特性

- **严格农田定义**: 仅使用ESA WorldCover class 40 (Cropland)
- **真实卫星数据**: 集成Google Earth Engine API
- **自动化处理**: 支持批量处理多个tiles
- **完整统计**: 生成详细的统计报告和可视化

### 适用场景

- 洪水灾害农业影响评估
- 农田受灾范围监测
- 灾后损失评估

### 重要提示

⚠️ **该地区(尼加拉瓜)按ESA定义几乎无传统农田**，严格定义下无法进行分析。如需分析该地区，建议使用扩展定义（草地+湿地）或更换研究区域。

---

## 环境配置

### 1. 系统要求

```
操作系统: Windows/Linux/macOS
Python版本: 3.8+
内存: 8GB+
硬盘空间: 10GB+
网络: 需稳定访问Google Earth Engine
```

### 2. 依赖安装

```bash
# 基础依赖
pip install numpy pillow

# Google Earth Engine (必需)
pip install earthengine-api

# 可选依赖
pip install scipy  # 用于模拟数据生成
pip install tqdm   # 进度条显示
```

### 3. GEE认证配置

**方法A: 使用项目ID**
```python
import ee
PROJECT_ID = 'neat-iterator-474909-s2'  # 替换为你的项目ID
ee.Initialize(project=PROJECT_ID)
```

**方法B: OAuth认证**
```bash
earthengine authenticate
# 按提示在浏览器中完成OAuth认证
```

---

## 快速开始

### 最小化示例

```bash
# 1. 下载WorldCover农田数据（前5个有洪水的tiles）
cd H:\FLOOD RISK\script
python download_worldcover_agricultural.py

# 2. 批量处理提取被淹没农田
python batch_process.py

# 3. 查看结果
cat ../results/summary_report.json
```

### 预期输出

```
下载完成: 5个tiles
  -> worldcover_tiles/[tile_id]/cropland_strict_mask.tif

处理完成: 5/5成功
  -> results/summary_report.json
  -> results/[tile_id]/flooded_cropland_mask.tif
```

---

## 详细使用步骤

### 步骤1: 准备输入数据

#### 1.1 洪水数据（已提供）

确认目录结构：
```
H:\FLOOD RISK\01\
├── [tile_id_1]/
│   ├── MK0_MLU_1111008_01_20200816.tif  # 洪水掩膜
│   └── info.json                         # 元数据
├── [tile_id_2]/
...
```

**洪水掩膜值说明**:
- 0: 陆地/干旱区域
- 1: 永久水体
- **2: 洪水/淹没区** ← 目标
- 3: NoData

#### 1.2 检查数据完整性

```python
# 检查有多少个有洪水的tiles
python -c "
from pathlib import Path
import numpy as np
from PIL import Image

flood_dir = Path(r'H:\FLOOD RISK\01')
count = 0
for tile_dir in flood_dir.iterdir():
    mlu_path = tile_dir / 'MK0_MLU_1111008_01_20200816.tif'
    if mlu_path.exists():
        mlu = np.array(Image.open(mlu_path))
        if np.sum(mlu == 2) > 0:
            count += 1
print(f'包含洪水的tiles: {count}个')
"
```

---

### 步骤2: 下载WorldCover农田数据

#### 2.1 修改配置（可选）

编辑 `download_worldcover_agricultural.py`:
```python
# 第18行
PROJECT_ID = 'your-project-id'  # 替换为你的GEE项目ID

# 第165行
def batch_download(flood_dir, output_dir, max_tiles=10):
    # max_tiles: 修改下载数量
```

#### 2.2 运行下载

```bash
python download_worldcover_agricultural.py
```

**输出**:
```
============================================================
批量下载WorldCover农田数据（严格定义）
============================================================
农田定义: class 40 (Cropland only)
  排除: 草地(30), 湿地(90)等其他类别

待下载tiles: 10个（有洪水）

[1/10]
处理tile: 0186935b5e345eaf8257...
  WorldCover分类:
      10: Tree cover - 41008px (81.7%)
      30: Grassland - 2212px (4.4%)
  *** 40: Cropland - 0px (0.0%)  ← 严格农田
      90: Herbaceous wetland - 5783px (11.5%)
  严格农田(class 40): 0px (0.0%)

...

成功: 10/10
包含农田(class 40)的tiles: 1/10
农田总像素: 1
```

#### 2.3 输出文件

```
H:\FLOOD RISK\worldcover_tiles\
├── [tile_id]/
│   ├── worldcover_full.tif              # 完整WorldCover分类
│   ├── cropland_strict_mask.tif         # 严格农田掩膜 (0或255)
│   └── worldcover_stats_strict.json     # 统计信息
└── download_report_strict.json          # 下载汇总报告
```

---

### 步骤3: 批量处理提取被淹没农田

#### 3.1 修改配置（可选）

编辑 `batch_process.py`:
```python
# 第39-48行
CONFIG = {
    'flood_dir': r'H:\FLOOD RISK\01',          # 洪水数据目录
    'worldcover_path': r'H:\FLOOD RISK\worldcover_cropland.tif',  # 未使用
    'output_dir': r'H:\FLOOD RISK\results',    # 输出目录
    'mlu_filename': 'MK0_MLU_1111008_01_20200816.tif',
    'flood_class': 2,        # 洪水的值
    'cropland_class': 40,    # 农田的值（严格定义）
    'pixel_size_m': 10,      # 像元大小
}
```

#### 3.2 运行批量处理

```bash
python batch_process.py
```

或手动指定范围：
```python
python -c "
from batch_process import *
from pathlib import Path

flood_dir = Path(r'H:\FLOOD RISK\01')
worldcover_path = Path(r'H:\FLOOD RISK\worldcover_cropland.tif')
output_dir = Path(r'H:\FLOOD RISK\results')

# 处理前10个tiles
results = batch_process_all_tiles(flood_dir, worldcover_path, output_dir)
generate_summary_report(results[:10], output_dir / 'summary_report.json')
"
```

#### 3.3 输出文件

```
H:\FLOOD RISK\results\
├── summary_report.json                    # 汇总报告
└── [tile_id]/
    ├── flooded_cropland_mask.tif          # 被淹没农田掩膜 (0或255)
    ├── visualization.png                  # 可视化图
    └── stats.json                         # 单tile统计
```

---

### 步骤4: 查看结果

#### 4.1 汇总报告

```bash
# 查看JSON报告
cat results/summary_report.json

# 或使用Python解析
python -c "
import json
with open('results/summary_report.json') as f:
    data = json.load(f)
    summary = data['summary']
    print(f'总tiles: {summary[\"total_tiles\"]}')
    print(f'洪水面积: {summary[\"total_flood_area_km2\"]:.2f} km^2')
    print(f'被淹没农田: {summary[\"total_flooded_cropland_area_km2\"]:.2f} km^2')
"
```

**报告内容**:
```json
{
  "summary": {
    "total_tiles": 10,
    "success_tiles": 10,
    "tiles_with_flood": 10,
    "total_flood_pixels": 25375,
    "total_cropland_pixels": 1,
    "total_flooded_cropland_pixels": 0,
    "total_flood_area_km2": 2.54,
    "total_cropland_area_km2": 0.0001,
    "total_flooded_cropland_area_km2": 0.0
  }
}
```

#### 4.2 可视化结果

打开任意tile的可视化图：
```bash
# Windows
explorer results\[tile_id]\visualization.png

# Linux
xdg-open results/[tile_id]/visualization.png
```

**图例**:
- 黄色: 农田（严格定义，class 40）
- 蓝色: 洪水
- 红色: 被淹没农田（重叠区）
- 黑色: 其他土地覆盖

---

## 输入输出说明

### 输入数据

#### 1. 洪水掩膜 (MLU)

| 属性 | 说明 |
|------|------|
| 文件名 | `MK0_MLU_1111008_01_20200816.tif` |
| 格式 | GeoTIFF |
| 数据类型 | uint8 |
| 大小 | 224×224像素 |
| 投影 | EPSG:3857 (Web Mercator) |
| 分辨率 | ~10m |
| 值域 | 0=陆地, 1=永久水体, 2=洪水, 3=NoData |

#### 2. WorldCover农田掩膜

| 属性 | 说明 |
|------|------|
| 文件名 | `cropland_strict_mask.tif` |
| 格式 | GeoTIFF |
| 数据类型 | uint8 |
| 大小 | 224×224像素 |
| 投影 | EPSG:3857 |
| 分辨率 | 10m |
| 值域 | 0=非农田, 255=农田(class 40) |

### 输出数据

#### 1. 被淹没农田掩膜

| 属性 | 说明 |
|------|------|
| 文件名 | `flooded_cropland_mask.tif` |
| 格式 | GeoTIFF |
| 数据类型 | uint8 |
| 大小 | 224×224像素 |
| 值域 | 0=非被淹没农田, 255=被淹没农田 |
| 生成方式 | flood_mask & cropland_mask (交集) |

#### 2. 统计报告

**单tile统计** (`stats.json`):
```json
{
  "status": "success",
  "tile_name": "0186935b5e345eaf8257eaafc3fa3875",
  "flood_date": "2020-08-15 08:00:00",
  "data_source": "WorldCover",
  "land": 48344,
  "permanent_water": 1051,
  "flood": 781,
  "nodata": 0,
  "total": 50176,
  "flood_pixels": 781,
  "cropland_pixels": 0,
  "flooded_cropland_pixels": 0,
  "flood_area_m2": 78100.0,
  "cropland_area_m2": 0.0,
  "flooded_cropland_area_m2": 0.0,
  "flood_cropland_ratio": 0.0,
  "cropland_flooded_ratio": 0.0
}
```

**汇总报告** (`summary_report.json`):
```json
{
  "summary": {
    "total_tiles": 10,
    "success_tiles": 10,
    "tiles_with_flood": 10,
    "total_flood_pixels": 25375,
    "total_cropland_pixels": 1,
    "total_flooded_cropland_pixels": 0,
    "total_flood_area_km2": 2.5375,
    "total_cropland_area_km2": 0.0001,
    "total_flooded_cropland_area_km2": 0.0
  },
  "per_tile_results": [...]
}
```

---

## 常见问题

### Q1: GEE认证失败

**症状**: `ee.Initialize()` 报错
```
Error: Please authorize access to your Earth Engine account
```

**解决**:
```bash
# 方法1: 命令行认证
earthengine authenticate

# 方法2: 在Python中认证
import ee
ee.Authenticate()
ee.Initialize(project='your-project-id')
```

---

### Q2: 下载超时

**症状**: `requests.get()` timeout
```
ReadTimeoutError: Read timed out after 60 seconds
```

**解决**:
```python
# 增加超时时间
response = requests.get(url, timeout=300)  # 5分钟
```

---

### Q3: 该地区无农田数据

**症状**: 所有tiles的农田像素为0
```
严格农田(class 40): 0px (0.0%)
```

**原因**: 该地区(尼加拉瓜)按ESA WorldCover分类几乎无传统农田

**解决方案**:

**选项A**: 使用扩展定义
```python
# 修改 download_worldcover_agricultural.py 第21行
CROPLAND_CLASS = 40  # 改为
AGRICULTURAL_CLASSES = [30, 40, 90]  # 包含草地+湿地

# 然后修改函数使用扩展定义
```

**选项B**: 更换研究区域
- 选择WorldCover中class 40占比高的区域
- 如: 中国东部平原、美国中西部、印度北部

**选项C**: 调整研究问题
- "洪水对湿地的影响" (class 90)
- "洪水对草地的影响" (class 30)

---

### Q4: 内存不足

**症状**: `MemoryError`

**解决**:
```python
# 减少一次处理的tiles数量
# 修改 batch_download(..., max_tiles=5)  # 从10改为5

# 或逐个处理
for tile_dir in tile_dirs:
    process_single_tile(tile_dir, ...)
```

---

### Q5: 投影不匹配

**症状**: 洪水和农田掩膜对不上

**检查**:
```python
from osgeo import gdal
ds1 = gdal.Open('MK0_MLU_*.tif')
ds2 = gdal.Open('cropland_strict_mask.tif')
print(ds1.GetProjection())
print(ds2.GetProjection())
# 应都为 EPSG:3857
```

**解决**: 确保下载时指定正确投影
```python
# download_worldcover_agricultural.py 第91行
url = worldcover_clipped.getDownloadURL({
    'crs': 'EPSG:3857',  # 必须与洪水数据一致
    ...
})
```

---

## API文档

### 主要函数

#### 1. `download_worldcover_cropland_strict()`

```python
def download_worldcover_cropland_strict(tile_dir, output_dir):
    """
    下载单个tile的WorldCover农田数据（严格定义）

    Args:
        tile_dir (Path): tile目录，包含info.json
        output_dir (Path): 输出目录

    Returns:
        cropland_mask (np.ndarray): 农田掩膜 (0或1)
        class_stats (dict): 各类别统计

    输出文件:
        - output_dir/[tile_id]/worldcover_full.tif
        - output_dir/[tile_id]/cropland_strict_mask.tif
        - output_dir/[tile_id]/worldcover_stats_strict.json
    """
```

**使用示例**:
```python
from pathlib import Path
from download_worldcover_agricultural import download_worldcover_cropland_strict

tile_dir = Path(r'H:\FLOOD RISK\01\0186935b5e345eaf8257eaafc3fa3875')
output_dir = Path(r'H:\FLOOD RISK\worldcover_tiles')

mask, stats = download_worldcover_cropland_strict(tile_dir, output_dir)
print(f'农田像素: {np.sum(mask)}')
```

---

#### 2. `process_single_tile()`

```python
def process_single_tile(tile_dir, worldcover_path, output_dir):
    """
    处理单个tile，提取被淹没农田

    Args:
        tile_dir (Path): tile目录
        worldcover_path (Path): WorldCover路径（未使用，兼容性保留）
        output_dir (Path): 输出目录

    Returns:
        stats (dict): 处理结果统计

    输出文件:
        - output_dir/[tile_id]/flooded_cropland_mask.tif
        - output_dir/[tile_id]/visualization.png
        - output_dir/[tile_id]/stats.json
    """
```

**使用示例**:
```python
from pathlib import Path
from batch_process import process_single_tile

tile_dir = Path(r'H:\FLOOD RISK\01\0186935b5e345eaf8257eaafc3fa3875')
output_dir = Path(r'H:\FLOOD RISK\results')

result = process_single_tile(tile_dir, None, output_dir)
print(f'状态: {result["status"]}')
print(f'被淹没农田: {result["flooded_cropland_pixels"]}像素')
```

---

#### 3. `batch_process_all_tiles()`

```python
def batch_process_all_tiles(flood_dir, worldcover_path, output_dir):
    """
    批量处理所有tiles

    Args:
        flood_dir (Path): 洪水数据目录
        worldcover_path (Path): WorldCover路径（未使用）
        output_dir (Path): 输出目录

    Returns:
        results (List[dict]): 所有tile的处理结果列表
    """
```

**使用示例**:
```python
from pathlib import Path
from batch_process import batch_process_all_tiles, generate_summary_report

flood_dir = Path(r'H:\FLOOD RISK\01')
output_dir = Path(r'H:\FLOOD RISK\results')

# 批量处理
results = batch_process_all_tiles(flood_dir, None, output_dir)

# 生成报告
generate_summary_report(results, output_dir / 'summary_report.json')
```

---

### 配置参数

#### CONFIG字典

```python
CONFIG = {
    'flood_dir': r'H:\FLOOD RISK\01',
    'worldcover_path': r'H:\FLOOD RISK\worldcover_cropland.tif',
    'output_dir': r'H:\FLOOD RISK\results',
    'mlu_filename': 'MK0_MLU_1111008_01_20200816.tif',
    'flood_class': 2,
    'cropland_class': 40,
    'pixel_size_m': 10,
}
```

**参数说明**:
- `flood_dir`: 洪水数据根目录
- `worldcover_path`: WorldCover文件路径（未使用，保留）
- `output_dir`: 处理结果输出目录
- `mlu_filename`: 洪水掩膜文件名
- `flood_class`: 洪水的像素值
- `cropland_class`: 农田的类别值（严格定义=40）
- `pixel_size_m`: 像元大小(米)，用于面积计算

---

## 附录

### A. WorldCover分类完整列表

| 值 | 名称 | 该地区占比 | 严格农田定义 |
|----|------|-----------|-------------|
| 10 | Tree cover (森林) | ~50-80% | ✗ |
| 20 | Shrubland (灌木) | <1% | ✗ |
| 30 | Grassland (草地) | ~1-9% | ✗ |
| **40** | **Cropland (农田)** | **<0.001%** | **✓** |
| 50 | Built-up (建筑) | 0% | ✗ |
| 60 | Bare/sparse vegetation | <0.1% | ✗ |
| 70 | Snow and ice | 0% | ✗ |
| 80 | Permanent water bodies | ~2-56% | ✗ |
| 90 | Herbaceous wetland (草本湿地) | ~10-70% | ✗ |
| 95 | Mangroves (红树林) | 0-47% | ✗ |
| 100 | Moss and lichen | 0% | ✗ |

---

### B. 文件清单

**脚本文件** (本目录):
```
script/
├── download_worldcover_agricultural.py   # WorldCover数据下载
├── batch_process.py                      # 批量处理主程序
├── feasibility_check.py                  # 可行性验证（参考）
└── 使用说明.md                           # 本文档
```

**测试报告** (上级目录):
```
../
├── TEST_REPORT_STRICT.md                 # 严格定义测试报告
├── TEST_REPORT_REALDATA.md               # 扩展定义测试报告
└── TEST_REPORT.md                        # 模拟数据测试报告
```

---

### C. 性能指标

| 操作 | 时间 | 内存 |
|------|------|------|
| 下载单tile (GEE) | ~3-5秒 | <50MB |
| 处理单tile | ~0.2秒 | <10MB |
| 批量处理10 tiles | ~5秒 | <100MB |
| 批量处理100 tiles | ~50秒 | <500MB |

---

### D. 技术栈

```
Python 3.8+
├── numpy          # 数组运算
├── pillow         # 图像处理
├── earthengine-api  # GEE数据访问
├── requests       # HTTP下载
├── scipy (可选)   # 形态学操作
└── tqdm (可选)    # 进度条
```

---

### E. 引用与致谢

**数据来源**:
- 洪水数据: Copernicus Emergency Management Service (EMS) - EMSR457
- WorldCover: ESA WorldCover 10m v100 (2020)
  - 引用: Zanaga et al. (2021), DOI: 10.5281/zenodo.5571936

**工具**:
- Google Earth Engine
- Sentinel-1 SAR

---

### F. 联系与支持

**问题反馈**: 请在项目repository提交issue
**文档版本**: v1.0
**最后更新**: 2025-12-21

---

**重要声明**: 该地区按照ESA严格农田定义无可分析数据，建议根据研究目标选择合适的定义或更换研究区域。
